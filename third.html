<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Flappy Bird</title>
    <style>
        body {
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background: skyblue;
        }
        canvas {
            background: linear-gradient(skyblue, lightgreen);
            display: block;
        }
        button.key{background:var(--btn);color:var(--text);border:0;padding:14px;border-radius:10px;font-size:18px;cursor:pointer;box-shadow:0 4px 0 rgba(0,0,0,0.25);transition:transform .08s ease,background .12s}
        button.key:active{transform:translateY(2px)}
        button.key.operator{background:linear-gradient(90deg,var(--accent),#4c8feb);font-weight:600}
        button.key.span-two{grid-column:span 2}

    </style>
</head>
<body>
<canvas id="gameCanvas" width="400" height="600"></canvas>
<script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");

    // Оригинальные параметры (я тронул только overlay и логику пола)
    let bird = { x: 50, y: 150, width: 20, height: 20, gravity: 0.1, lift: -3, velocity: 0 };
    let pipes = [];
    let frame = 0;
    let score = 0;

    // состояния игры
    let gameRunning = false; // когда true — игра двигается
    let gameOver = false;

    function drawBird() {
        ctx.fillStyle = "yellow";
        ctx.fillRect(bird.x, bird.y, bird.width, bird.height);
    }

    function drawPipes() {
        ctx.fillStyle = "green";
        pipes.forEach(pipe => {
            ctx.fillRect(pipe.x, 0, pipe.width, pipe.top);
            ctx.fillRect(pipe.x, canvas.height - pipe.bottom, pipe.width, pipe.bottom);
        });
    }

    function updateBird() {
        bird.velocity += bird.gravity;
        bird.y += bird.velocity;

        // **ЗДЕСЬ**: падение на пол — НЕ приводит к смерти. Птичка просто останавливается на полу.
        if (bird.y + bird.height > canvas.height) {
            bird.y = canvas.height - bird.height;
            bird.velocity = 0;
            // Нельзя выставлять gameOver = true здесь (так, как было у тебя раньше).
        }
        if (bird.y < 0) {
            bird.y = 0;
            bird.velocity = 0;
        }
    }

    function updatePipes() {
        if (frame % 120 === 0) {
            let gap = 120;
            let top = Math.random() * (canvas.height - gap - 100) + 50;
            let bottom = canvas.height - top - gap;
            pipes.push({ x: canvas.width, width: 40, top: top, bottom: bottom });
        }

        pipes.forEach(pipe => {
            pipe.x -= 1.5;
            if (pipe.x + pipe.width < 0) {
                // сохраняем прежнюю логику: shift удаляет первый элемент
                pipes.shift();
                score++;
            }
        });
    }

    function detectCollision() {
        for (let pipe of pipes) {
            if (
                bird.x < pipe.x + pipe.width &&
                bird.x + bird.width > pipe.x &&
                (bird.y < pipe.top || bird.y + bird.height > canvas.height - pipe.bottom)
            ) {
                gameOver = true;
            }
        }
    }

    function resetGame() {
        bird.y = 150;
        bird.velocity = 0;
        pipes = [];
        score = 0;
        frame = 0;
        gameOver = false;
        gameRunning = false; // ждем старта (нажатием)
    }

    function drawScore() {
        ctx.fillStyle = "black";
        ctx.font = "20px Arial";
        ctx.textAlign = "left";
        ctx.fillText("Score: " + score, 10, 25);
    }

    // Надёжный перенос/разбивка текста по строкам, чтобы ничего не вылазило
    function wrapTextLines(text, maxWidth, font) {
        ctx.font = font;
        const words = text.split(' ');
        const lines = [];
        let current = '';

        for (let i = 0; i < words.length; i++) {
            const word = words[i];
            const test = current ? current + ' ' + word : word;
            const w = ctx.measureText(test).width;
            if (w > maxWidth && current) {
                lines.push(current);
                current = word;
            } else {
                current = test;
            }
        }
        if (current) lines.push(current);
        return lines;
    }

    function drawOverlay(message) {
        // затемнение
        ctx.fillStyle = "rgba(0,0,0,0.55)";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // подготовка текста
        const maxTextWidth = canvas.width * 0.86;
        const titleFont = "22px Arial";
        const smallFont = "16px Arial";

        // разбиваем на строки
        const lines = wrapTextLines(message, maxTextWidth, titleFont);

        // рисуем строки по центру, вертикально центрируем блок
        const lineHeight = 26;
        const totalHeight = lines.length * lineHeight;
        let startY = (canvas.height / 2) - (totalHeight / 2);

        ctx.fillStyle = "#ffffff";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.font = titleFont;
        for (let i = 0; i < lines.length; i++) {
            ctx.fillText(lines[i], canvas.width / 2, startY + i * lineHeight);
        }
    }

    function gameLoop() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // рисуем текущее состояние (статично, если не запущена)
        drawPipes();
        drawBird();
        drawScore();

        if (gameRunning) {
            // обновления выполняются только в игровом режиме
            updateBird();
            updatePipes();
            detectCollision();

            // увеличиваем frame только в игровом режиме, чтобы пауза действительно была паузой
            frame++;

            if (gameOver) {
                gameRunning = false; // перейти в состояние "пауза + экран конца"
            }
        } else {
            // игра на паузе — показываем стартовый или конечный экран
            if (gameOver) {
                drawOverlay("Игра окончена! Нажми пробел или клик, чтобы перезапустить" + " Score : " + score);
            } else {
                drawOverlay("Нажми пробел или клик, чтобы начать");
            }
        }

        requestAnimationFrame(gameLoop);
    }

    // flap: если игра не запущена — запускаем (или перезапускаем, если была кончина), затем дергаем
    function flap() {
        if (!gameRunning) {
            if (gameOver) {
                resetGame();
            }
            gameRunning = true;
        }
        bird.velocity = bird.lift;
    }

    // привязки управления
    document.addEventListener("keydown", function(e) {
        if (e.code === "Space") {
            flap();
        }
    });

    document.addEventListener("mousedown", function() {
        flap();
    });

    // старт цикла
    gameLoop();
</script>
<button class="key"><a href="/UltraApp" style="color: white; text-decoration: none">Go Back</a></button>
</body>
</html>

